# Vault Security Audit: Bitxen Inheritance

## 1. Overview
This document outlines the security audit findings for the Bitxen Inheritance (deheritance) project, focusing on the `Bitxen.sol` smart contract and its integration with the frontend and backend services.

**Current Audit Status:** ðŸ”´ CRITICAL VULNERABILITY FOUND
**Target Contract:** `Bitxen.sol`

---

## 2. Critical Findings: Security Bypass Analysis

### 2.1 The "Public Secret" Vulnerability (CRITICAL)
*   **Vulnerability Type:** Sensitive Data Exposure in Transaction Calldata.
*   **Description:** The frontend generates a `secret` (random 32-byte hex) and sends it as a plaintext parameter to the `registerData` function in the smart contract.
*   **Bypass Mechanism:** Although the `_vaultSecrets` mapping in the contract is marked `private`, all transaction input data on the blockchain is public.
*   **Impact:** Any malicious actor can monitor the blockchain or use a block explorer to extract the `secret` from the transaction input within milliseconds of vault creation. This bypasses the intended "inheritance release" logic.

### 2.2 Static Metadata Encryption Key (MEDIUM)
*   **Vulnerability Type:** Weak Key Derivation.
*   **Description:** The backend (`vault-service.ts`) uses a hardcoded salt (`"wishlist-ai-security-questions-v1"`) with PBKDF2 to derive metadata encryption keys from the `vaultId`.
*   **Impact:** Since `vaultId` is public (stored on Arweave and the blockchain), an attacker can easily recreate the encryption key and decrypt sensitive metadata, including security question hashes and Shamir sharing configurations.

### 2.3 `releaseEntropy` vs. Manual `secret`
*   **Finding:** The contract provides a `releaseEntropy` field, but it is **not generated automatically** during registration if a `releaseDate` is set. It only becomes non-zero after a release function (`releaseData`, `finalizeRelease`, or `manualRelease`) is called.
*   **Logic Flaw:** The current frontend implementation attempts to fill this "gap" by sending a manual `secret` during registration, which leads to the leak described in 2.1.

---

## 3. Security Gatekeepers in Bitxen.sol

The following mechanisms are correctly implemented as logical gatekeepers:
1.  **DAO Threshold:** Economic parameters (fees/burn rates) are locked until 5,000,000 records are reached.
2.  **Ownership Check:** `require(core.owner == msg.sender)` ensures only the vault creator can modify or delete their records.
3.  **Reentrancy Guard:** Protective measures on state-changing functions like `registerData` and `deleteData`.
4.  **Release Date Barrier:** Functions `getVaultSecret` and `getReleaseEntropy` strictly enforce time-based access control.

---

## 4. Remediation Strategy (No Contract Changes)

Since the `Bitxen.sol` contract remains immutable, the following architectural changes are required to secure the system:

### 4.1 Implementation of the "Sleeping Key" Strategy
*   **Step 1:** Stop sending real decryption keys to the `params.secret` field during registration. Send `0x0` or a non-sensitive hash instead.
*   **Step 2:** Redesign the frontend to use `releaseEntropy` (generated by the contract *at the time of release*) as the primary salt for the final decryption key.
*   **Step 3:** Require a "Finalization Transaction" (`finalizeRelease`) by the beneficiary. This transaction triggers the creation of `releaseEntropy` on-the-fly using `block.prevrandao`, ensuring the key never existed on the blockchain prior to the release.

### 4.2 Metadata Privacy Hardening
*   **Action:** Change the metadata encryption salt in the backend to a dynamic value (e.g., a hash of the owner's address + vault creation timestamp).

### 4.3 Mandatory Client-Side Encryption
*   **Action:** Ensure that all master keys are split using Shamir's Secret Sharing (SSS) and encrypted using AES-256-GCM at the client level. The blockchain should only act as a **Status Gatekeeper** and **Anchor of Integrity** (`commitment`), not a storage for raw secrets.

---

## 5. Conclusion
The `Bitxen.sol` contract is logically sound as a registry, but its use as a "secret vault" is currently bypassed by the transparency of blockchain transactions. By moving the secret management to a **Client-Side-First** architecture and relying on the contract's atomic entropy generation at release time, the security flaws can be mitigated without redeploying the contract.
